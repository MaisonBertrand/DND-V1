import{H as u,M as v,X as T,U as I,W as L}from"./index-c208d5f4.js";const k=[{id:"goblin",name:"Goblin",type:"Humanoid",cr:"1/4",hp:"7 (2d6)",ac:15,speed:"30 ft.",stats:{str:8,dex:14,con:10,int:10,wis:8,cha:8},actions:[{name:"Scimitar",type:"Melee Weapon Attack",attack:"+4",damage:"1d6+2 slashing"},{name:"Shortbow",type:"Ranged Weapon Attack",attack:"+4",damage:"1d6+2 piercing",range:"80/320 ft."}],description:"Small, green-skinned humanoids that live in caves and ruins."},{id:"orc",name:"Orc",type:"Humanoid",cr:"1/2",hp:"15 (2d8+6)",ac:13,speed:"30 ft.",stats:{str:16,dex:12,con:16,int:7,wis:11,cha:10},actions:[{name:"Greataxe",type:"Melee Weapon Attack",attack:"+5",damage:"1d12+3 slashing"},{name:"Javelin",type:"Ranged Weapon Attack",attack:"+5",damage:"1d6+3 piercing",range:"30/120 ft."}],description:"Large, muscular humanoids with tusks and greenish skin."},{id:"dragon",name:"Young Red Dragon",type:"Dragon",cr:"10",hp:"178 (17d10+85)",ac:18,speed:"40 ft., fly 80 ft.",stats:{str:23,dex:14,con:21,int:14,wis:11,cha:19},actions:[{name:"Bite",type:"Melee Weapon Attack",attack:"+10",damage:"2d10+6 piercing"},{name:"Claw",type:"Melee Weapon Attack",attack:"+10",damage:"2d6+6 slashing"},{name:"Fire Breath",type:"Cone",damage:"7d6 fire",save:"DC 17 Dex"}],description:"A young red dragon with scales the color of molten rock."},{id:"skeleton",name:"Skeleton",type:"Undead",cr:"1/4",hp:"13 (2d8+4)",ac:13,speed:"30 ft.",stats:{str:10,dex:14,con:15,int:6,wis:8,cha:5},actions:[{name:"Shortsword",type:"Melee Weapon Attack",attack:"+4",damage:"1d6+2 piercing"},{name:"Shortbow",type:"Ranged Weapon Attack",attack:"+4",damage:"1d6+2 piercing",range:"80/320 ft."}],description:"Animated bones that serve dark masters."},{id:"wolf",name:"Wolf",type:"Beast",cr:"1/4",hp:"11 (2d8+2)",ac:13,speed:"40 ft.",stats:{str:12,dex:15,con:12,int:3,wis:12,cha:6},actions:[{name:"Bite",type:"Melee Weapon Attack",attack:"+4",damage:"1d6+1 piercing"}],description:"A fierce wolf with sharp teeth and keen senses."}],C=[{id:"sword",name:"Longsword",type:"Weapon",rarity:"Common",damage:"1d8 slashing",properties:["Versatile (1d10)"],description:"A standard longsword with a sharp blade."},{id:"shield",name:"Shield",type:"Armor",rarity:"Common",ac:"+2",properties:["Shield"],description:"A wooden shield for protection."},{id:"potion",name:"Healing Potion",type:"Consumable",rarity:"Common",effect:"2d4+2 healing",description:"A red potion that restores hit points."},{id:"bow",name:"Shortbow",type:"Weapon",rarity:"Common",damage:"1d6 piercing",properties:["Ammunition","Range (80/320)"],description:"A simple wooden bow for ranged attacks."},{id:"armor",name:"Leather Armor",type:"Armor",rarity:"Common",ac:"+1",properties:["Light Armor"],description:"Light leather armor for mobility."}],A=[{id:"fireball",name:"Fireball",level:3,school:"Evocation",castingTime:"1 action",range:"150 feet",components:["V","S","M"],duration:"Instantaneous",damage:"8d6 fire",save:"DC 15 Dex",description:"A bright streak flashes from your pointing finger to a point you choose within range."},{id:"cure_wounds",name:"Cure Wounds",level:1,school:"Evocation",castingTime:"1 action",range:"Touch",components:["V","S"],duration:"Instantaneous",healing:"1d8+modifier",description:"A creature you touch regains a number of hit points equal to 1d8 + your spellcasting ability modifier."},{id:"magic_missile",name:"Magic Missile",level:1,school:"Evocation",castingTime:"1 action",range:"120 feet",components:["V","S"],duration:"Instantaneous",damage:"1d4+1 force per missile",description:"You create three glowing darts of magical force."},{id:"lightning_bolt",name:"Lightning Bolt",level:3,school:"Evocation",castingTime:"1 action",range:"Self (100-foot line)",components:["V","S","M"],duration:"Instantaneous",damage:"8d6 lightning",save:"DC 15 Dex",description:"A stroke of lightning forming a line of 100 feet long and 5 feet wide blasts out from you."},{id:"shield",name:"Shield",level:1,school:"Abjuration",castingTime:"1 reaction",range:"Self",components:["V","S"],duration:"1 round",effect:"+5 AC until start of next turn",description:"An invisible barrier of magical force appears and protects you."}],b={rollDie(h){return Math.floor(Math.random()*h)+1},rollDice(h){const r=h.match(/(\d+)d(\d+)/);if(!r)return 0;const e=parseInt(r[1]),t=parseInt(r[2]);let a=0;for(let o=0;o<e;o++)a+=this.rollDie(t);return a},rollWithModifier(h){const r=h.split("+"),e=r[0],t=r.length>1?parseInt(r[1]):0;return this.rollDice(e)+t},rollInitiative(h=0){return this.rollDie(20)+h},rollDamage(h){return this.rollDice(h)},rollAttack(h=0){return this.rollDie(20)+h}};class W{constructor(){this.initiativeOrder=[],this.currentTurn=0,this.round=1,this.combatActive=!1}getMonsterById(r){return k.find(e=>e.id===r)}searchMonsters(r){const e=r.toLowerCase();return k.filter(t=>t.name.toLowerCase().includes(e)||t.type.toLowerCase().includes(e)||t.description.toLowerCase().includes(e))}getRandomMonster(){return k[Math.floor(Math.random()*k.length)]}getItemById(r){return C.find(e=>e.id===r)}searchItems(r){const e=r.toLowerCase();return C.filter(t=>t.name.toLowerCase().includes(e)||t.type.toLowerCase().includes(e)||t.description.toLowerCase().includes(e))}getRandomItem(){return C[Math.floor(Math.random()*C.length)]}getSpellById(r){return A.find(e=>e.id===r)}searchSpells(r){const e=r.toLowerCase();return A.filter(t=>t.name.toLowerCase().includes(e)||t.school.toLowerCase().includes(e)||t.description.toLowerCase().includes(e))}getSpellsByLevel(r){return A.filter(e=>e.level===r)}getRandomSpell(){return A[Math.floor(Math.random()*A.length)]}async rollInitiative(r,e){try{const t=e.map(n=>{const c=b.rollInitiative(n.initiativeModifier||0);return{id:n.id,name:n.name,type:n.type,roll:c-(n.initiativeModifier||0),modifier:n.initiativeModifier||0,total:c,initiative:c,position:n.position||null,hp:n.hp||0,maxHp:n.maxHp||0,ac:n.ac||10,spells:n.spells||[],character:n.character||null,monster:n.monster||null}});t.sort((n,c)=>c.initiative-n.initiative);const a=await u(r);if(!a)throw new Error("Campaign story not found");const o=this.cleanDataForFirestore(t),i={...a,combat:{...a==null?void 0:a.combat,initiativeOrder:o,currentTurn:0,round:1,active:!0,startedAt:new Date}},s=this.cleanDataForFirestore(i);return await v(a.id,s),t}catch(t){throw console.error("Error rolling initiative:",t),t}}async getInitiativeOrder(r){var e;try{const t=await u(r);return((e=t==null?void 0:t.combat)==null?void 0:e.initiativeOrder)||[]}catch(t){throw console.error("Error getting initiative order:",t),t}}async nextTurn(r){try{const e=await u(r);if(!e)throw new Error("Campaign story not found");const t=e==null?void 0:e.combat;if(!t||!t.active)throw new Error("No active combat");let a=t.currentTurn+1,o=t.round;a>=t.initiativeOrder.length&&(a=0,o=t.round+1);const i={...e,combat:{...t,currentTurn:a,round:o}},s=this.cleanDataForFirestore(i);return await v(e.id,s),{currentTurn:a,round:o,currentParticipant:t.initiativeOrder[a]}}catch(e){throw console.error("Error advancing turn:",e),e}}async endCombat(r){try{const e=await u(r);if(!e)throw new Error("Campaign story not found");const t={...e,combat:{...e==null?void 0:e.combat,active:!1,endedAt:new Date}},a=this.cleanDataForFirestore(t);return await v(e.id,a),!0}catch(e){throw console.error("Error ending combat:",e),e}}async getCombatState(r){try{const e=await u(r);return(e==null?void 0:e.combat)||null}catch(e){throw console.error("Error getting combat state:",e),e}}cleanDataForFirestore(r){if(r==null)return null;if(typeof r=="object"&&!Array.isArray(r)){const e={};for(const[t,a]of Object.entries(r)){const o=this.cleanDataForFirestore(a);o!==void 0&&(e[t]=o)}return e}return Array.isArray(r)?r.map(e=>this.cleanDataForFirestore(e)).filter(e=>e!==void 0):r}async saveCombatSetup(r,e){try{const t=await u(r);if(!t)throw new Error("Campaign story not found");const a=this.cleanDataForFirestore(e),o={...t,combat:{...t==null?void 0:t.combat,setup:a,lastUpdated:new Date}},i=this.cleanDataForFirestore(o);return await v(t.id,i),!0}catch(t){throw console.error("Error saving combat setup:",t),t}}async addParticipant(r,e){try{const t=await u(r);if(!t)throw new Error("Campaign story not found");const a=t==null?void 0:t.combat;if(!a||!a.active)throw new Error("No active combat");const o=b.rollInitiative(e.initiativeModifier||0),i=e.initiativeModifier||0,s={id:e.id,name:e.name,type:e.type,roll:o-i,modifier:i,total:o,initiative:o},n=[...a.initiativeOrder,s];n.sort((d,p)=>p.initiative-d.initiative);const c=this.cleanDataForFirestore(n),l={...t,combat:{...a,initiativeOrder:c}},m=this.cleanDataForFirestore(l);return await v(t.id,m),s}catch(t){throw console.error("Error adding participant:",t),t}}async removeParticipant(r,e){try{const t=await u(r);if(!t)throw new Error("Campaign story not found");const a=t==null?void 0:t.combat;if(!a||!a.active)throw new Error("No active combat");const o=a.initiativeOrder.filter(l=>l.id!==e);let i=a.currentTurn;a.currentTurn>=o.length&&(i=0);const s=this.cleanDataForFirestore(o),n={...t,combat:{...a,initiativeOrder:s,currentTurn:i}},c=this.cleanDataForFirestore(n);return await v(t.id,c),!0}catch(t){throw console.error("Error removing participant:",t),t}}async listenToCombatState(r,e){try{const t=await u(r);if(!t)return console.error("Campaign story not found for partyId:",r),null;const a=T(I,"campaignStories",t.id);return L(a,o=>{if(o.exists()){const s=o.data().combat;s&&e(s)}})}catch(t){return console.error("Error setting up combat state listener:",t),null}}async getCombatSetup(r){try{const e=await u(r);if(!e)return null;const t=e==null?void 0:e.combat;return!t||!t.setup?null:t.setup}catch(e){return console.error("Error loading combat setup:",e),null}}calculateInitiativeModifier(r){return Math.floor((r-10)/2)}calculateDistance(r,e){return Math.abs(r.x-e.x)+Math.abs(r.y-e.y)}parseHpString(r){const e=r.match(/(\d+)\s*\(([^)]+)\)/);return e?{average:parseInt(e[1]),dice:e[2]}:{average:parseInt(r)||10,dice:"1d8"}}createEnemyFromMonster(r){const e=this.parseHpString(r.hp),t=this.calculateInitiativeModifier(r.stats.dex);return{id:`enemy_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,name:r.name,type:"enemy",hp:e.average,maxHp:e.average,ac:r.ac,initiativeModifier:t,stats:r.stats,actions:r.actions,description:r.description,monster:r}}async performAttack(r,e,t,a,o=null){var i,s;try{const n=await u(r);if(!n)throw new Error("Campaign story not found");const c=n==null?void 0:n.combat;if(!c||!c.active)throw new Error("No active combat");const l=c.initiativeOrder.find(f=>f.id===e),m=c.initiativeOrder.find(f=>f.id===t);if(!l||!m)throw new Error("Attacker or target not found");let d;if(l.type==="enemy"?d=(s=(i=l.monster)==null?void 0:i.actions)==null?void 0:s.find(f=>f.name===a):d={name:a||"Basic Attack",type:"Melee Weapon Attack",attack:"+0",damage:"1d6"},!d)throw new Error("Action not found");let p=0;if(l.type==="enemy")p=parseInt(d.attack.replace("+",""))||0;else{const f=l.character;if(f){const E=Math.floor((f.strength-10)/2),S=Math.floor((f.dexterity-10)/2);p=Math.max(E,S)}}let g;o&&o.attack?g=o.attack:g=b.rollAttack(p);const x=m.ac||10,F=g>=x,O=g===20;let y=0,D="";if(F){if(O){let w,M;o&&o.damage?(w=o.damage,M=o.criticalDamage||b.rollDamage(d.damage)):(w=b.rollDamage(d.damage),M=b.rollDamage(d.damage)),y=w+M,D=`Critical Hit! ${w} + ${M} = ${y}`}else o&&o.damage?y=o.damage:y=b.rollDamage(d.damage),D=`Hit! ${y} damage`;const f=c.initiativeOrder.map(w=>{if(w.id===t){const M=Math.max(0,w.hp-y);return{...w,hp:M}}return w}),E={...n,combat:{...c,initiativeOrder:f}},S=this.cleanDataForFirestore(E);await v(n.id,S)}return{attacker:l.name,target:m.name,action:d.name,attackRoll:g,attackBonus:p,targetAC:x,isHit:F,isCritical:O,damage:y,damageDetails:D,targetNewHp:m.hp-y}}catch(n){throw console.error("Error performing attack:",n),n}}async getAvailableActions(r,e){var t;try{const a=await u(r);if(!a)throw new Error("Campaign story not found");const o=a==null?void 0:a.combat;if(!o||!o.active)throw new Error("No active combat");const i=o.initiativeOrder.find(s=>s.id===e);if(!i)throw new Error("Combatant not found");if(i.type==="enemy"){const s=((t=i.monster)==null?void 0:t.actions)||[];return[{name:"Move",type:"Movement",description:"Move to a new position on the grid"},...s]}else return[{name:"Move",type:"Movement",description:"Move to a new position on the grid"},{name:"Basic Attack",type:"Melee Weapon Attack",attack:"+0",damage:"1d6",range:"5 ft."},{name:"Ranged Attack",type:"Ranged Weapon Attack",attack:"+0",damage:"1d6",range:"15 ft."}]}catch(a){throw console.error("Error getting available actions:",a),a}}async getValidTargets(r,e,t){try{const a=await u(r);if(!a)throw new Error("Campaign story not found");const o=a==null?void 0:a.combat;if(!o||!o.active)throw new Error("No active combat");const i=o.initiativeOrder.find(n=>n.id===e);if(!i)throw new Error("Attacker not found");if(t==="Move")return this.getValidMovementPositions(r,e);const s=o.initiativeOrder.filter(n=>n.id!==e&&n.hp>0);return i.position?s.filter(n=>{var l;if(!n.position)return!1;const c=this.calculateDistance(i.position,n.position);if(t==="Basic Attack")return c<=1;if(t==="Ranged Attack")return c<=3;if(i.type==="enemy"&&i.monster){const m=(l=i.monster.actions)==null?void 0:l.find(d=>d.name===t);if(m&&m.range){const d=m.range.match(/(\d+)/);if(d){const p=Math.ceil(parseInt(d[1])/5);return c<=p}}}return c<=1}):[]}catch(a){throw console.error("Error getting valid targets:",a),a}}async getValidMovementPositions(r,e){try{const t=await u(r);if(!t)throw new Error("Campaign story not found");const a=t==null?void 0:t.combat;if(!a||!a.active)throw new Error("No active combat");const o=a.initiativeOrder.find(c=>c.id===e);if(!o||!o.position)return[];const i=o.position,s=1,n=[];for(let c=-s;c<=s;c++)for(let l=-s;l<=s;l++){if(c===0&&l===0||Math.abs(c)+Math.abs(l)>1)continue;const m=i.x+c,d=i.y+l;m>=0&&m<12&&d>=0&&d<8&&(a.initiativeOrder.some(g=>g.position&&g.position.x===m&&g.position.y===d)||n.push({id:`pos_${m}_${d}`,name:`Position (${m}, ${d})`,type:"position",x:m,y:d,distance:Math.abs(c)+Math.abs(l)}))}return n}catch(t){throw console.error("Error getting valid movement positions:",t),t}}async performMovement(r,e,t){try{const a=await u(r);if(!a)throw new Error("Campaign story not found");const o=a==null?void 0:a.combat;if(!o||!o.active)throw new Error("No active combat");const i=o.initiativeOrder.find(d=>d.id===e);if(!i)throw new Error("Combatant not found");const s=i.position,n={x:t.x,y:t.y},c=o.initiativeOrder.map(d=>d.id===e?{...d,position:n}:d),l={...a,combat:{...o,initiativeOrder:c}},m=this.cleanDataForFirestore(l);return await v(a.id,m),{combatant:i.name,oldPosition:s,newPosition:n,movementDistance:Math.abs(n.x-s.x)+Math.abs(n.y-s.y)}}catch(a){throw console.error("Error performing movement:",a),a}}async performAction(r,e,t,a,o=null){var i;try{let s;if(a==="Move"){const m={x:parseInt(t.split("_")[1]),y:parseInt(t.split("_")[2])};s=await this.performMovement(r,e,m)}else s=await this.performAttack(r,e,t,a,o);const n=await u(r),c=n==null?void 0:n.combat,l=(i=c==null?void 0:c.initiativeOrder)==null?void 0:i.find(m=>m.id===e);return l&&l.type==="player"&&await this.nextTurn(r),s}catch(s){throw console.error("Error performing action:",s),s}}}const B=new W;export{B as a,k as b,C as c,A as d,b as m};
